# 代理模式
1. 代理模式的原理与实现
   在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情
   况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原
   始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法
   来实现代理模式。
2. 动态代理的原理与实现
   静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式
   的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动
   态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类
   对应的代理类，然后在系统中用代理类替换掉原始类。
3. 代理模式的应用场景
   代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事
   务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只
   需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。
Spring AOP 底层的实现原理就是基于动态代理。

代理模式代理处理的是与原始类无关的功能  和代理模式很像


JDK动态代理和CGLIB动态代理区别
1.JDK动态代理是Java自带的，cglib动态代理是第三方jar包提供的。

2.JDK动态代理是针对拥有接口的目标类进行动态代理的，而Cglib是非final类都可以进行动态代理。 但是Spring优先使用JDK动态代理。

3.JDK动态代理实现的逻辑是目标类和代理类都实现同一个接口，目标类和代理类是平级的。而Cglib动 态代理实现的逻辑是给目标类生个孩子（子类，也就是代理类），目标类和代理类是父子继承关系。（字节码增强、生成真实类）

4.JDK动态代理在早期的JDK1.6左右性能比cglib差，但是在JDK1.8以后cglib和jdk的动态代理性能 基本上差不多。反而jdk动态代理性能更加的优越。

代理和装饰者区别 
代理符合里式替换原则 不会改变原有逻辑的正确性 是业务的增强
装饰者是原有类的扩展 可以扩展出别的行为


代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。