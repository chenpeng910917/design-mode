# 设计模式
## 设计原则
SOLID、KISS、YAGNI、DRY、LOD
SOLID 原则并非单纯的 1 个原则，而是由 5
个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则
和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。

单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描
述是这样的：A class or module should have a single reponsibility。如果我们把它翻译
成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）
### 1、单一职责原则（SRP）
单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也
就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类
包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成
多个功能更加单一、粒度更细的类。
如何理解单一职责原则（SRP）？
一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的
类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护
性。
如何判断类的职责是否足够单一？
不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可
能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，
出现下面这些情况就有可能说明这类的设计不满足单一职责原则：
类中的代码行数、函数或者属性过多；
类依赖的其他类过多，或者依赖类的其他类过多；
私有方法过多；
比较难给类起一个合适的名字；
类中大量的方法都是集中操作类中的某几个属性。
类的职责是否设计得越单一越好？
单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚
性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此
来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内
聚性，也会影响代码的可维护性。

### 2、开闭原则OCP
添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法 等）。
1). 如何理解“对扩展开放、对修改关闭”？
添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性
等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们
有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价
来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修
改”；在细代码粒度下，可能又被认定为“扩展”。
2). 如何做到“对扩展开放、修改关闭”？
我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考
一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未
来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活
地插入到扩展点上。
很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23
种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为
指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编
程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

### 3、里式替换原则（LSP）
里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最
核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数
的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有
的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至
包括注释中所罗列的任何特殊说明。
里式替换原则跟多态的区别。虽然从定义描述和代码实现上
来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一
大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种
设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不
改变原有程序的逻辑及不破坏原有程序的正确性。
### 4、接口隔离原则（ISP）
1)、如何理解“接口隔离原则”？

	理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。
如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口
等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分
调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我
们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那
接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

2)、接口隔离原则与单一职责原则的区别

	单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面
更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接
口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分
接口或接口的部分功能，那接口的设计就不够职责单一。

### 5、依赖反转原则（IOC）

1)、控制反转
实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导
框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在
没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流
程通过框架来控制。流程的控制权从程序员“反转”给了框架。
2)、 依赖注入
依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内
部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等
方式传递（或注入）给类来使用。
3)、依赖注入框架
我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关
系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员
来做的事情。© 版权归极客邦科技所有，未经许可不得传播售卖。 页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。
4)、依赖反转原则
依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面
的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细
节，具体实现细节依赖抽象。


### 6、KISS原则(尽量保持简单)、YAGNI原则(要不要做)

如何写出满足 KISS 原则的代码？
实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。
不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编
程语言中过于高级的语法等。
不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出
bug 的概率会更高，维护的成本也比较高。
不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件
语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。
实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉
得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还
有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你
的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。

KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数
来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码
的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之
外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。

不要使用同事可能不懂的技术来实现代码；
不要重复造轮子，要善于使用已经有的工具类库；
不要过度优化。

YAGNI 跟 KISS 说的是一回事吗？   
YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的
是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前
不需要的就不要做）。

### 7、DRY 原则（Don’t Repeat Yourself）(不要重复自己)

1)、DRY 原则我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻
辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重
复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。
2)、代码复用性
今天，我们讲到提高代码可复用性的一些方法，有以下 7 点。
减少代码耦合
满足单一职责原则
模块化
业务与非业务逻辑分离
通用代码下沉
继承、多态、抽象、封装
应用模板等设计模式

实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数
的时候，要像设计一个外部 API 一样去思考它的复用性。
我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明
确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新
的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可
复用。
相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定
不能写重复的代码。

### 8、迪米特法则（LOD)(最少知识原则)

1)、 如何理解“高内聚、松耦合”？
“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，
缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指
导类与类之间依赖关系的设计。
所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相
近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代
码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会
或者很少导致依赖类的代码改动。
2)、 如何理解“迪米特法则”？
不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接
口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其
他部分。一旦发生变化，需要了解这一变化的类就会比较少。

“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，
缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设
计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。
单一职责原则
我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的
重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它
的类和它依赖的类就会比较少，代码耦合也就相应的降低了。
基于接口而非实现编程
基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处
是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或
类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。
依赖注入
跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依
赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么
紧密，容易做到插拔替换。
多用组合少用继承
我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一
发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，
这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种
解耦的有效手段。
迪米特法则
迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽
量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的
松耦合。